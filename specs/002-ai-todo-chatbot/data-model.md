# Data Model: AI-Powered Todo Chatbot

**Feature**: 002-ai-todo-chatbot
**Date**: 2026-01-11
**Purpose**: Define database schema and entity relationships for Phase III

## Entity Relationship Diagram

```
┌─────────────────┐
│     User        │
│  (Phase II)     │
│─────────────────│
│ id: UUID (PK)   │
│ email: String   │
│ password_hash   │
│ created_at      │
└─────────────────┘
        │
        │ 1:N
        ├──────────────────────────────┐
        │                              │
        ▼                              ▼
┌─────────────────┐          ┌─────────────────┐
│  Conversation   │          │      Task       │
│   (Phase III)   │          │   (Phase II)    │
│─────────────────│          │─────────────────│
│ id: UUID (PK)   │          │ id: UUID (PK)   │
│ user_id: UUID   │◄─────────│ user_id: UUID   │
│ created_at      │          │ title: String   │
│ updated_at      │          │ is_completed    │
└─────────────────┘          │ created_at      │
        │                    │ updated_at      │
        │ 1:N                └─────────────────┘
        │
        ▼
┌─────────────────┐
│    Message      │
│  (Phase III)    │
│─────────────────│
│ id: UUID (PK)   │
│ conversation_id │
│ role: Enum      │
│ content: Text   │
│ tool_calls: JSON│
│ tool_results    │
│ created_at      │
└─────────────────┘
```

## Entities

### User (Existing - Phase II)

**Purpose**: Represents an authenticated user of the application.

**Schema**:
```python
class User(SQLModel, table=True):
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(unique=True, index=True, max_length=255)
    password_hash: str = Field(max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationships
    conversations: List["Conversation"] = Relationship(back_populates="user")
    tasks: List["Task"] = Relationship(back_populates="user")
```

**Validation Rules**:
- Email must be valid format (validated by Better Auth)
- Email must be unique across all users
- Password hash generated by Better Auth

**Indexes**:
- Primary key: `id`
- Unique index: `email`

---

### Conversation (New - Phase III)

**Purpose**: Represents a chat session between a user and the AI agent. Each conversation contains multiple messages and maintains context across turns.

**Schema**:
```python
class Conversation(SQLModel, table=True):
    __tablename__ = "conversations"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationships
    user: User = Relationship(back_populates="conversations")
    messages: List["Message"] = Relationship(
        back_populates="conversation",
        sa_relationship_kwargs={"cascade": "all, delete-orphan"}
    )
```

**Validation Rules**:
- `user_id` must reference an existing user
- `updated_at` automatically updated on any message addition
- Conversations cannot be shared between users

**Indexes**:
- Primary key: `id`
- Foreign key index: `user_id`

**Lifecycle**:
- Created: When user starts a new chat session
- Updated: When new messages are added
- Deleted: When user deletes conversation (cascade deletes all messages)

**Business Rules**:
- One user can have multiple conversations
- Each conversation belongs to exactly one user
- Conversations are isolated by user (enforced at query level)

---

### Message (New - Phase III)

**Purpose**: Represents a single message in a conversation. Messages can be from the user, the AI assistant, or system notifications. Messages also store tool calls and their results for full conversation replay.

**Schema**:
```python
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

class Message(SQLModel, table=True):
    __tablename__ = "messages"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    conversation_id: UUID = Field(foreign_key="conversations.id", index=True)
    role: MessageRole = Field(sa_column=Column(Enum(MessageRole)))
    content: str = Field(sa_column=Column(Text))
    tool_calls: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    tool_results: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    # Relationships
    conversation: Conversation = Relationship(back_populates="messages")
```

**Validation Rules**:
- `conversation_id` must reference an existing conversation
- `role` must be one of: user, assistant, system
- `content` is required (cannot be empty string)
- `tool_calls` and `tool_results` are optional JSON fields
- Messages are immutable once created (no updates)

**Indexes**:
- Primary key: `id`
- Foreign key index: `conversation_id`
- Index: `created_at DESC` (for efficient history retrieval)

**Field Details**:

**`role`**: Enum indicating message source
- `user`: Message from the human user
- `assistant`: Message from the AI agent
- `system`: System-generated message (e.g., "Conversation started")

**`content`**: The text content of the message
- For user messages: The natural language input
- For assistant messages: The AI-generated response
- For system messages: Status or informational text

**`tool_calls`**: JSON array of tool invocations (optional)
```json
[
  {
    "id": "call_abc123",
    "type": "function",
    "function": {
      "name": "add_task",
      "arguments": "{\"title\": \"buy groceries\"}"
    }
  }
]
```

**`tool_results`**: JSON array of tool execution results (optional)
```json
[
  {
    "tool_call_id": "call_abc123",
    "role": "tool",
    "content": "{\"success\": true, \"task_id\": \"uuid\", \"title\": \"buy groceries\"}"
  }
]
```

**Lifecycle**:
- Created: When user sends message or agent responds
- Read: When fetching conversation history
- Never updated or deleted individually (immutable)

**Business Rules**:
- Messages are ordered chronologically by `created_at`
- Tool calls and results are stored for full conversation replay
- Messages inherit user isolation from parent conversation

---

### Task (Existing - Phase II, Enhanced for Phase III)

**Purpose**: Represents a todo item. Tasks are managed through MCP tools called by the AI agent.

**Schema**:
```python
class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", index=True)
    title: str = Field(max_length=500)
    is_completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationships
    user: User = Relationship(back_populates="tasks")
```

**Validation Rules**:
- `user_id` must reference an existing user
- `title` is required and cannot be empty
- `title` max length: 500 characters
- `is_completed` defaults to False
- `updated_at` automatically updated on any modification

**Indexes**:
- Primary key: `id`
- Foreign key index: `user_id`
- Composite index: `(user_id, is_completed)` for efficient filtering

**Lifecycle**:
- Created: Via MCP `add_task` tool
- Read: Via MCP `list_tasks` tool
- Updated: Via MCP `update_task` or `complete_task` tools
- Deleted: Via MCP `delete_task` tool

**Business Rules**:
- Tasks are isolated by user (all queries filtered by user_id)
- Task titles are matched using fuzzy matching for natural language references
- Completed tasks remain in database (not automatically deleted)

---

## Database Migrations

**Migration 001: Add Conversations and Messages Tables**

```sql
-- Create conversations table
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Create messages table
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tool_calls JSONB,
    tool_results JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_conversations_user_id ON conversations(user_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at DESC);

-- Add composite index for task filtering
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, is_completed);
```

**Rollback**:
```sql
DROP INDEX IF EXISTS idx_tasks_user_completed;
DROP INDEX IF EXISTS idx_messages_created_at;
DROP INDEX IF EXISTS idx_messages_conversation_id;
DROP INDEX IF EXISTS idx_conversations_user_id;
DROP TABLE IF EXISTS messages;
DROP TABLE IF EXISTS conversations;
```

---

## Data Access Patterns

### Pattern 1: Create New Conversation
```python
async def create_conversation(user_id: UUID) -> Conversation:
    conversation = Conversation(user_id=user_id)
    db.add(conversation)
    await db.commit()
    await db.refresh(conversation)
    return conversation
```

### Pattern 2: Fetch Conversation History (Last 50 Messages)
```python
async def get_conversation_history(
    conversation_id: UUID,
    user_id: UUID,
    limit: int = 50
) -> List[Message]:
    # Verify conversation belongs to user (security check)
    conversation = await db.query(Conversation).filter(
        Conversation.id == conversation_id,
        Conversation.user_id == user_id
    ).first()

    if not conversation:
        raise NotFoundError("Conversation not found")

    # Fetch last N messages in reverse chronological order
    messages = await db.query(Message).filter(
        Message.conversation_id == conversation_id
    ).order_by(Message.created_at.desc()).limit(limit).all()

    # Return in chronological order (oldest first)
    return list(reversed(messages))
```

### Pattern 3: Save Message with Tool Calls
```python
async def save_message(
    conversation_id: UUID,
    role: MessageRole,
    content: str,
    tool_calls: Optional[dict] = None,
    tool_results: Optional[dict] = None
) -> Message:
    message = Message(
        conversation_id=conversation_id,
        role=role,
        content=content,
        tool_calls=tool_calls,
        tool_results=tool_results
    )
    db.add(message)

    # Update conversation timestamp
    await db.execute(
        update(Conversation)
        .where(Conversation.id == conversation_id)
        .values(updated_at=datetime.utcnow())
    )

    await db.commit()
    await db.refresh(message)
    return message
```

### Pattern 4: List User's Conversations
```python
async def list_user_conversations(
    user_id: UUID,
    limit: int = 20,
    offset: int = 0
) -> List[Conversation]:
    conversations = await db.query(Conversation).filter(
        Conversation.user_id == user_id
    ).order_by(
        Conversation.updated_at.desc()
    ).limit(limit).offset(offset).all()

    return conversations
```

### Pattern 5: MCP Tool - List Tasks
```python
async def mcp_list_tasks(user_id: UUID) -> List[Task]:
    """MCP tool implementation for listing tasks"""
    tasks = await db.query(Task).filter(
        Task.user_id == user_id
    ).order_by(Task.created_at.desc()).all()

    return tasks
```

---

## Data Isolation Enforcement

**Strategy**: All database queries MUST filter by `user_id` extracted from JWT token.

**Implementation**:
1. JWT verification extracts `user_id` at endpoint level
2. `user_id` passed to all service functions
3. All queries include `WHERE user_id = ?` clause
4. Foreign key relationships enforce cascading isolation

**Example - Secure Query**:
```python
# ✅ CORRECT: Filters by user_id
async def get_task(task_id: UUID, user_id: UUID) -> Task:
    task = await db.query(Task).filter(
        Task.id == task_id,
        Task.user_id == user_id  # Security check
    ).first()
    return task
```

**Example - Insecure Query**:
```python
# ❌ WRONG: Missing user_id filter
async def get_task(task_id: UUID) -> Task:
    task = await db.query(Task).filter(
        Task.id == task_id
    ).first()
    return task  # Could return another user's task!
```

---

## Performance Considerations

**Query Optimization**:
- Index on `conversations.user_id` for fast user conversation lookup
- Index on `messages.conversation_id` for fast message retrieval
- Index on `messages.created_at DESC` for efficient history pagination
- Composite index on `tasks(user_id, is_completed)` for filtered task lists

**Expected Query Performance**:
- Fetch conversation history (50 messages): <50ms
- Create new message: <20ms
- List user conversations: <30ms
- MCP tool operations: <50ms each

**Connection Pooling**:
- Use asyncpg connection pool with 10-20 connections
- Configure pool timeout: 30 seconds
- Max overflow: 5 connections

---

## Data Retention and Cleanup

**Phase III Scope**:
- No automatic cleanup or archival
- All conversations and messages retained indefinitely
- Users cannot delete conversations (future feature)

**Future Considerations**:
- Archive conversations older than 90 days
- Implement conversation deletion endpoint
- Add soft delete for tasks
- Implement data export for GDPR compliance

---

## Testing Data

**Seed Data for Development**:
```python
# Create test user
user = User(
    email="test@example.com",
    password_hash="hashed_password"
)

# Create test conversation
conversation = Conversation(user_id=user.id)

# Create test messages
messages = [
    Message(
        conversation_id=conversation.id,
        role=MessageRole.USER,
        content="Add a task to buy groceries"
    ),
    Message(
        conversation_id=conversation.id,
        role=MessageRole.ASSISTANT,
        content="I've created a task for you: 'buy groceries'",
        tool_calls=[{
            "id": "call_123",
            "function": {"name": "add_task", "arguments": '{"title": "buy groceries"}'}
        }],
        tool_results=[{
            "tool_call_id": "call_123",
            "content": '{"success": true, "task_id": "uuid", "title": "buy groceries"}'
        }]
    )
]

# Create test tasks
tasks = [
    Task(user_id=user.id, title="buy groceries", is_completed=False),
    Task(user_id=user.id, title="call mom", is_completed=True)
]
```

---

## Summary

**New Tables**: 2 (conversations, messages)
**Modified Tables**: 1 (tasks - added composite index)
**Total Entities**: 4 (User, Conversation, Message, Task)
**Relationships**: 3 (User→Conversations, User→Tasks, Conversation→Messages)
**Indexes**: 6 total (3 new, 1 enhanced)
